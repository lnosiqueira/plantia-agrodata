import oracledb

# === CONFIGURAÇÕES DO BANCO ORACLE (FIAP) ===
DB_USER = "rm567893"                  # <- MESMO user do test_oracle.py
DB_PASSWORD = "040782"                # <- MESMA senha do test_oracle.py
DB_DSN = "oracle.fiap.com.br:1521/ORCL"  # <- MESMO DSN do test_oracle.py

def conectar():
    return oracledb.connect(user=DB_USER, password=DB_PASSWORD, dsn=DB_DSN)


def criar_tabela():
    with conectar() as conn:
        cur = conn.cursor()
        cur.execute("""
        BEGIN
          EXECUTE IMMEDIATE q'[
            CREATE TABLE colheita (
              id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              field_id      NUMBER NOT NULL,
              tipo_colheita VARCHAR2(20),
              area_ha       NUMBER,
              perda_percent NUMBER(5,2),
              data_colheita DATE DEFAULT SYSDATE
            )
          ]';
        EXCEPTION WHEN OTHERS THEN
          IF SQLCODE != -955 THEN RAISE; END IF; -- tabela já existe
        END;""")
        conn.commit()
    print("✅ Tabela 'colheita' pronta no banco.")

def inserir_colheita(field_id: int, tipo_colheita: str, area_ha: float, perda_percent: float):
    with conectar() as conn:
        cur = conn.cursor()
        cur.execute(
            "INSERT INTO colheita (field_id, tipo_colheita, area_ha, perda_percent) "
            "VALUES (:1, :2, :3, :4)",
            (field_id, tipo_colheita, area_ha, perda_percent)
        )
        conn.commit()
    print("🌱 Registro inserido.")

from datetime import date

def inserir_em_lote(registros):
    """
    UPSERT (MERGE) de uma lista de dicts do JSON na tabela COLHEITA.
    Chave natural: (field_id, TRUNC(data_colheita)).
    Se o JSON não tiver "date", usa a data de hoje.
    Formato opcional de data no JSON: "YYYY-MM-DD".
    """
    if not registros:
        print("⚠️ Nenhum registro para inserir.")
        return

    # Normaliza linhas (garante tipos e data)
    rows = []
    for r in registros:
        field_id = int(r.get("field_id", 0))
        method = r.get("method", "desconhecida")
        area_ha = float(r.get("area_ha", 1.0))
        perda = float(r.get("loss_percentage", 0.0))
        date_str = r.get("date")  # ex.: "2025-10-14"; se None, usa hoje
        rows.append((field_id, method, area_ha, perda, date_str))

    merge_sql = """
    MERGE INTO colheita c
    USING (
      SELECT :field_id AS field_id,
             :tipo_colheita AS tipo_colheita,
             :area_ha AS area_ha,
             :perda AS perda_percent,
             NVL(TO_DATE(:data_str, 'YYYY-MM-DD'), TRUNC(SYSDATE)) AS dt
      FROM dual
    ) src
    ON (c.field_id = src.field_id AND TRUNC(c.data_colheita) = src.dt)
    WHEN MATCHED THEN
      UPDATE SET
        c.tipo_colheita = src.tipo_colheita,
        c.area_ha       = src.area_ha,
        c.perda_percent = src.perda_percent
    WHEN NOT MATCHED THEN
      INSERT (field_id, tipo_colheita, area_ha, perda_percent, data_colheita)
      VALUES (src.field_id, src.tipo_colheita, src.area_ha, src.perda_percent, src.dt)
    """

    with conectar() as conn:
        cur = conn.cursor()
        for (fid, method, area, perda, date_str) in rows:
            cur.execute(merge_sql, dict(
                field_id=fid,
                tipo_colheita=method,
                area_ha=area,
                perda=perda,
                data_str=date_str
            ))
        conn.commit()

    print(f"✅ {len(rows)} registros upsert (sem duplicar).")
